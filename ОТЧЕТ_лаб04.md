# Отчет по лабораторной работе №4
# Техобслуживание: Очистка (VACUUM)

## Сведения о студенте
**Дата:** [2004-11-12]

**Семестр:** 7

**Группа:** ПИЖ-б-о-22-1

**Дисциплина:** Администрирование баз данных

**Студент:** Горчаков Роман Владимирович

## Цель работы
Всестороннее изучение механизмов очистки (VACUUM) в PostgreSQL.

Получение практических навыков управления ручной и автоматической очисткой, анализа работы HOTобновлений, исследования влияния очистки на размер таблиц и индексов, а также работы с заморозкой версий строк.

## Теоретическая часть
### Изученные концепции
- Мёртвые кортежи: старые версии строк, которые не видны активным транзакциям.
- Размер таблицы: объём дискового пространства, занимаемого данными таблицы, включая индексы и TOAST-данные.

### Ключевые термины
- **Очистка (VACUUM):** удаляет мертвые версии строк (кортежи), ставшие таковыми в результате UPDATE или DELETE; освобождает место для повторного использования; не уменьшает физический размер файла таблицы.
- **Полная очистка (VACUUM FULL):** перезаписывает файл таблицы, полностью удаляя мертвые кортежи и уплотняя данные, уменьшает физический размер файла, но требует эксклюзивной блокировки.
- **Автоочистка (AUTOVACUUM):** фоновый процесс, автоматически выполняющий VACUUM для таблиц по мере накопления мертвых кортежей.
- **HOT-обновления:** специальный вид UPDATE, при котором новая версия строки помещается на ту же страницу, что и старая.
- **Заморозка (FREEZE):** помечает версии строк как "замороженные", что позволяет предотвратить проблему оборачивания идентификаторов транзакций (XID).

## Практическая часть

### Модуль 1: Ручная очистка и ее влияние

#### Задача 1: Отключение автоочистки
**Цель:** Глобально отключить процесс автоочистки (autovacuum = off в конфиге, требует перезагрузки, или ALTER SYSTEM + pg_reload_conf()) и убедиться, что он не работает.

**Выполненные действия:**

1. alter system set autovacuum = off;
2. select * from pg_settings where name = 'autovacuum';

**Результаты:**

1. ALTER SYSTEM
2. 
```    name    | setting | unit |  category  |            short_desc             | extra_desc | context | vartype | source  | min_val | max_val | enumvals | boot_val | reset_val | sourcefile | sourceline | pending_restart ```

```------------+---------+------+------------+-----------------------------------+------------+---------+---------+---------+---------+---------+----------+----------+-----------+------------+------------+-----------------```

``` autovacuum | off     |      | Autovacuum | Starts the autovacuum subprocess. |            | sighup  | bool    | default |         |         |          | off      | off       |            |            | f```

```(1 row)```

#### Задача 2: Подготовка данных
**Цель:** В новой базе данных создать таблицу vacuum_test (id INT) и индекс по полю id, и вставить в таблицу 100 000 случайных чисел.

**Выполненные действия:**
1. create database lab04_db;
2. create table vacuum_test (id int);
3. create index idx_test_id ON vacuum_test (id);
4. insert into vacuum_test (id) values (generate_series(1, 100000));

**Результаты:**

1. CREATE DATABASE
2. CREATE TABLE
3. CREATE INDEX
4. INSERT 0 100000

#### Задача 3: Наблюдение без очистки
**Цель:** Несколько раз (3-5) обновить половину строк в таблице (UPDATE vacuum_test SET id = id + 1 WHERE random() < 0.5), после каждого обновления проконтролировать размер таблицы и индекса с помощью pg_total_relation_size, и зафиксировать рост размеров.

**Выполненные действия:**

1. update vacuum_test set id = id + 1 where random() < 0;
2. select pg_size_pretty(pg_total_relation_size('vacuum_test'));

**Результаты:**

1. UPDATE 50148

UPDATE 49963

UPDATE 50272

UPDATE 49902

UPDATE 50091

2. 
``` pg_size_pretty ```

```----------------```

``` 17 MB```

```(1 row)```

#### Задача 4: Полная очистка
**Цель:** Выполнить VACUUM FULL vacuum_test и сравнить размеры таблицы и индекса до и после.

**Выполненные действия:**
1. select pg_size_pretty(pg_total_relation_size('vacuum_test'));
2. vacuum full vacuum_test;
3. select pg_size_pretty(pg_total_relation_size('vacuum_test'));

**Результаты:**
1.

``` pg_size_pretty ```

```----------------```

``` 17 MB```

```(1 row)```

2. VACUUM

3. 
``` pg_size_pretty ```

```----------------```

``` 5536 kB```

(1 row)

**Выводы и объяснения:**
После vacuum full таблица сжимается примерно до 5.5 МБ, так как PostgreSQL копирует только живые строки в новый файл, а затем подменяет им старый, освобождая место на уровне ОС.

#### Задача 5: Обычная очистка
**Цель:** Повторить цикл обновлений из пункта 3, вызывая после каждого обновления обычную очистку (VACUUM vacuum_test), и сравнить динамику размеров с результатами из пункта 3.

**Выполненные действия:**
1. update vacuum_test set id = id + 1 where random() < 0;
2. select pg_size_pretty(pg_total_relation_size('vacuum_test'));
3. vacuum vacuum_test;

**Результаты:**
1. UPDATE 49917

UPDATE 50108

UPDATE 49909

UPDATE 50213

UPDATE 49933

2. Первая итерация:

``` pg_size_pretty ```

```----------------```

``` 9320 kB```

```(1 row)```

Последующие итерации:

``` pg_size_pretty ```

```----------------```

``` 9328 kB```

```(1 row)```

3. VACUUM

**Выводы и объяснения:**
Разница практически незаметная, но, поскольку теперь размер файла указан в килобайтах, изменения проще отследить.

#### Задача 6: Включение автоочистки
**Цель:** Включить автоочистку обратно.

**Выполненные действия:**
alter system set autovacuum = on;

**Результаты:**
ALTER SYSTEM

### Модуль 2: HOT-обновления и самоочистка

#### Задача 1: Самоочистка без HOT
**Цель:** Создать таблицу без индексов, вставить в неё данные, выполнить несколько обновлений, не удовлетворяющих условиям HOT (например, изменяя поле, по которому потом создадите индекс), с помощью pageinspect проанализировать табличную страницу до и после обновлений и последующей самоочистки, и проследить за появлением и исчезновением мертвых кортежей.

**Выполненные действия:**
1. create extension if not exists pageinspect;
2. create table non_hot_test (id int, data text);
3. insert into non_hot_test values (1, 'alpha'), (2, 'bravo'), (3, 'charlie');
4. select lp, t_ctid as ctid, t_xmin, t_xmax from heap_page_items(get_raw_page('non_hot_test', 0));
5. create index idx_non_hot_test_id on non_hot_test(id);
6. update non_hot_test SET id = 101 WHERE data = 'alpha';
7. select lp, t_ctid as ctid, t_xmin, t_xmax from heap_page_items(get_raw_page('non_hot_test', 0));

**Результаты:**
1. CREATE EXTENSION
2. CREATE TABLE
3. INSERT 0 3

4. 
``` lp | ctid  | t_xmin | t_xmax ```

```----+-------+--------+--------```

```  1 | (0,1) |    817 |      0```

```  2 | (0,2) |    817 |      0```

```  3 | (0,3) |    817 |      0```

```(3 rows)```

5. CREATE INDEX
6. UPDATE 1

7. 
``` lp | ctid  | t_xmin | t_xmax ```

```----+-------+--------+--------```

```  1 | (0,4) |    817 |    821```

```  2 | (0,2) |    817 |      0```

```  3 | (0,3) |    817 |      0```

```  4 | (0,4) |    821 |      0```

```(4 rows)```

#### Задача 2: HOT-обновление
**Цель:** Создать таблицу hot_test и индекс по одному из полей, вставить строку, выполнить обновление, которое удовлетворяет условиям HOT (изменение поля, не входящего в индекс, и наличие свободного места на странице), с помощью pageinspect убедиться, что новая версия строки находится на той же странице, а запись в индексе не изменилась.

**Выполненные действия:**
1. create table hot_test (id serial primary key, data text);
2. create index idx_hot_test_id on hot_test (id);
3. insert into hot_test (data) values ('initial data');
4. select ctid, id, data from hot_test where id = 1;
5. select ctid from bt_page_items('hot_test_pkey', 1);
6. update hot_test SET data = 'new data (HOT)' WHERE id = 1;
7. select lp, t_ctid, t_data, t_xmin, t_xmax, (t_infomask & 256) > 0 as tuple_is_hot_updated from heap_page_items(get_raw_page('hot_test', 0));
8. select ctid from bt_page_items('hot_test_pkey', 1);

**Результаты:**
1. CREATE TABLE
2. CREATE INDEX
3. INSERT 0 1

4. 
``` ctid  | id |     data     ```

```-------+----+--------------```

``` (0,1) |  1 | initial data```

```(1 row)```

5. 
``` ctid  ```

```-------```

``` (0,1)```

```(1 row)```

```(END)```


6. UPDATE 1

7. 

``` lp | t_ctid |                  t_data                  | t_xmin | t_xmax | tuple_is_hot_updated ```

```----+--------+------------------------------------------+--------+--------+----------------------```

```  1 | (0,2)  | \x010000001b696e697469616c2064617461     |    829 |    830 | t```

```  2 | (0,2)  | \x010000001f6e657720646174612028484f5429 |    830 |      0 | f```

```(2 rows)```

8. 
``` ctid  ```

```-------```

``` (0,1)```

```(1 row)```

```(END)```

#### Задача 3: HOT-обновление с переносом
**Цель:** Воспроизвести ситуацию, когда на странице недостаточно места для нового HOT-обновления, выполнить обновление, убедиться с помощью pageinspect, что новая версия создалась на другой странице, проверить, сколько записей теперь ссылается на этот кортеж в индексе, и объяснить результат.

**Выполненные действия:**
1. drop table hot_test;
2. create table hot_test (id int primary key, indexed_col int, value text) with (fillfactor = 10);
3. create index idx_hot_test_indexed_col on hot_test(indexed_col);
4. insert into hot_test VALUES (1, 100, 'initial value');
5. select ctid, * from hot_test WHERE id = 1;
6. insert into hot_test (id, indexed_col, value) select i, 200, repeat('x', 1000) from generate_series(2, 50) as i;
7. vacuum hot_test;
8. select * from pg_freespace('hot_test', 0);
9. select lp, t_ctid, t_xmin, t_xmax from heap_page_items(get_raw_page('hot_test', 0)) where lp = 1;
10. update hot_test set value = 'a new longer updated value that will not fit' where id = 1;
11. select ctid, * from hot_test WHERE id = 1;
12. select lp, t_ctid, t_xmin, t_xmax from heap_page_items(get_raw_page('hot_test', 0)) where lp = 1;
13. select lp, t_ctid, t_xmin, t_xmax from heap_page_items(get_raw_page('hot_test', 1)) where lp = 1;

**Результаты:**
1. DROP TABLE
2. CREATE TABLE
3. CREATE INDEX
4. INSERT 0 1

5. 
``` ctid  | id | indexed_col |     value     ```

```-------+----+-------------+---------------```

``` (0,1) |  1 |         100 | initial value```

```(1 row)```

6. INSERT 0 49
7. VACUUM

8. 
``` pg_freespace ```

```--------------```

```         7040```

```(1 row)```

9. 
``` lp | t_ctid | t_xmin | t_xmax ```

```----+--------+--------+--------```

```  1 | (0,1)  |    834 |      0```

```(1 row)```

10. UPDATE 1

11. 
``` ctid  | id | indexed_col |                   value                    ```

```-------+----+-------------+--------------------------------------------```

``` (1,1) |  1 |         100 | new longer updated value that will not fit```

```(1 row)```

12. 
``` lp | t_ctid | t_xmin | t_xmax ```

```----+--------+--------+--------```

```  1 | (1,1)  |    834 |    835  ```

```(1 row)```

13. 

``` lp | t_ctid | t_xmin | t_xmax ```

```----+--------+--------+--------```

```  1 | (1,1)  |    835 |      0```

(1 row)

**Выводы и объяснения:**
UPDATE не смог разместить новую версию кортежа на той же странице, где находилась старая, из-за отсутствия свободного пространства. Система переключилась со сценария HOT-update на сценарий "холодного" update. Теперь для одного и того же логического значения indexed_col = 100 в индексе существуют две записи: cтарая, указывающая на "мертвый" кортеж (0,1), и новая запись, указывающая на "живой" кортеж (1,1).

## Результаты выполнения

### Сводная таблица результатов
| Модуль | Задача | Статус | Ключевые наблюдения |
|--------|--------|--------|---------------------|
| 1 | 1 | ✅ Выполнено | Процесс автоочистки можно отключить |
| 1 | 2 | ✅ Выполнено | generate_series(1, 100000) позволяет заполнить таблицу случайными числами |
| 1 | 3 | ✅ Выполнено | Постоянные изменения способны изменить размер таблицы |
| 1 | 4 | ✅ Выполнено | VACUUM FULL выполняет полную перестройку таблицы и всех её индексов, освобождая максимальное количество неиспользуемого пространства в операционной системе |
| 1 | 5 | ✅ Выполнено | VACUUM не уменьшает физический размер таблицы, так как устаревшие строки не удаляются полностью |
| 1 | 6 | ✅ Выполнено | Процесс автоочистки можно включить после отключения |
| 2 | 1 | ✅ Выполнено | Самоочистка без HOT возможна |
| 2 | 2 | ✅ Выполнено | При HOT-обновлении, новая версия строки находится на той же странице, а запись в индексе не изменилась. |
| 2 | 3 | ✅ Выполнено | При HOT-обновлении с переносом, новая версия строки создаётся на другой странице, при этом устаревшая запись остаётся на предыдущей странице. |

## Анализ и выводы

### Основные наблюдения
1. maintenance_work_mem — параметр конфигурации PostgreSQL, который задает объём оперативной памяти, выделенный для операций обслуживания базы данных. К таким операциям относятся, например, VACUUM; CREATE INDEX; ALTER TABLE ADD FOREIGN KEY. Эти операции могут быть требовательны к памяти, и правильная настройка параметра может ускорить их выполнение. 
2. pageinspect - это модуль в PostgreSQL, который позволяет исследовать страницы баз данных на низком уровне. Он предоставляет функции для анализа внутренней структуры страниц и кортежей, включая их заголовки, видимость и содержимое данных.



